https://claude.ai/public/artifacts/e86e17bb-a1b8-4923-83e1-5ad275fac04a

# M1 IPv6 Packet Counter - Complete Implementation Guide

## Prerequisites Setup (Oracle VM)

### 1. Install Required Packages
```bash
# Update system
sudo apt update && sudo apt upgrade -y

# Install kernel headers and build tools
sudo apt install -y linux-headers-$(uname -r) build-essential

# Install development tools
sudo apt install -y gcc make libc6-dev

# Verify kernel headers installation
ls /lib/modules/$(uname -r)/build
```

### 2. Verify Netfilter Support
```bash
# Check if netfilter is available
sudo modprobe nf_conntrack
lsmod | grep nf_conntrack
```

## Basic Level Implementation

### File: `ipv6_counter.c`

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/netfilter.h>
#include <linux/netfilter_ipv6.h>
#include <linux/skbuff.h>
#include <linux/ip.h>
#include <linux/ipv6.h>
#include <linux/proc_fs.h>
#include <linux/uaccess.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Student");
MODULE_DESCRIPTION("IPv6 Packet Counter");
MODULE_VERSION("1.0");

// Global counter for IPv6 packets
static unsigned long ipv6_packet_count = 0;

// Proc entry
static struct proc_dir_entry *proc_entry;

// Netfilter hook structure
static struct nf_hook_ops nfho;

// Hook function - called for every packet
static unsigned int hook_func(void *priv, struct sk_buff *skb,
                             const struct nf_hook_state *state)
{
    struct ipv6hdr *ipv6_header;
    
    // Check if packet has IPv6 header
    if (!skb)
        return NF_ACCEPT;
    
    // Get IPv6 header
    ipv6_header = ipv6_hdr(skb);
    if (!ipv6_header)
        return NF_ACCEPT;
    
    // Increment counter for IPv6 packets
    ipv6_packet_count++;
    
    // Print every 100th packet to avoid log spam
    if (ipv6_packet_count % 100 == 0) {
        printk(KERN_INFO "IPv6 Counter: %lu packets processed\n", ipv6_packet_count);
    }
    
    return NF_ACCEPT;  // Let packet continue
}

// Proc file read function
static ssize_t proc_read(struct file *file, char __user *usr_buf, 
                        size_t count, loff_t *pos)
{
    char buf[64];
    int len;
    
    if (*pos > 0)
        return 0;
    
    len = snprintf(buf, sizeof(buf), "IPv6 packets: %lu\n", ipv6_packet_count);
    
    if (copy_to_user(usr_buf, buf, len))
        return -EFAULT;
    
    *pos = len;
    return len;
}

// Proc file operations
static const struct proc_ops proc_file_ops = {
    .proc_read = proc_read,
};

// Module initialization
static int __init init_ipv6_counter(void)
{
    printk(KERN_INFO "IPv6 Counter: Module loaded\n");
    
    // Create proc entry
    proc_entry = proc_create("ipv6_counter", 0444, NULL, &proc_file_ops);
    if (!proc_entry) {
        printk(KERN_ERR "IPv6 Counter: Failed to create proc entry\n");
        return -ENOMEM;
    }
    
    // Set up netfilter hook
    nfho.hook = hook_func;
    nfho.hooknum = NF_INET_PRE_ROUTING;  // Hook at pre-routing
    nfho.pf = PF_INET6;                  // IPv6 protocol family
    nfho.priority = NF_IP6_PRI_FIRST;    // High priority
    
    // Register the hook
    if (nf_register_net_hook(&init_net, &nfho)) {
        printk(KERN_ERR "IPv6 Counter: Failed to register netfilter hook\n");
        proc_remove(proc_entry);
        return -1;
    }
    
    printk(KERN_INFO "IPv6 Counter: Hook registered successfully\n");
    return 0;
}

// Module cleanup
static void __exit cleanup_ipv6_counter(void)
{
    // Unregister netfilter hook
    nf_unregister_net_hook(&init_net, &nfho);
    
    // Remove proc entry
    if (proc_entry)
        proc_remove(proc_entry);
    
    printk(KERN_INFO "IPv6 Counter: Module unloaded. Final count: %lu\n", 
           ipv6_packet_count);
}

module_init(init_ipv6_counter);
module_exit(cleanup_ipv6_counter);
```

### File: `Makefile`

```makefile
# Makefile for IPv6 Counter kernel module

obj-m += ipv6_counter.o

# Kernel build directory
KDIR := /lib/modules/$(shell uname -r)/build

# Default target
all:
	$(MAKE) -C $(KDIR) M=$(PWD) modules

# Clean target
clean:
	$(MAKE) -C $(KDIR) M=$(PWD) clean
	rm -f *.o *.ko *.mod.c *.mod *.symvers *.order

# Install target
install: all
	sudo insmod ipv6_counter.ko

# Uninstall target
uninstall:
	sudo rmmod ipv6_counter

# Show module info
info:
	modinfo ipv6_counter.ko

.PHONY: all clean install uninstall info
```

## Building and Testing

### 1. Compile the Module
```bash
# Navigate to your project directory
cd ~/ipv6_counter_project

# Build the module
make

# Check if compilation was successful
ls -la *.ko
```

### 2. Load and Test the Module
```bash
# Load the module
sudo make install
# or
sudo insmod ipv6_counter.ko

# Verify module is loaded
lsmod | grep ipv6_counter

# Check kernel messages
dmesg | tail -10

# Check proc entry
cat /proc/ipv6_counter
```

### 3. Generate IPv6 Traffic for Testing
```bash
# Enable IPv6 if not already enabled
sudo sysctl net.ipv6.conf.all.disable_ipv6=0

# Generate some IPv6 traffic
ping6 -c 5 ::1                    # Ping IPv6 loopback
ping6 -c 5 2001:4860:4860::8888   # Ping Google's IPv6 DNS (if available)

# Or use wget/curl with IPv6
curl -6 -I http://ipv6.google.com/ 2>/dev/null || echo "IPv6 internet not available"

# Check the counter
cat /proc/ipv6_counter

# Monitor kernel messages
sudo dmesg | grep "IPv6 Counter"
```

### 4. Unload the Module
```bash
# Unload the module
sudo make uninstall
# or
sudo rmmod ipv6_counter

# Check final messages
dmesg | tail -5
```

## Debugging Tips

### Common Issues and Solutions

1. **Compilation Errors**:
   ```bash
   # Make sure kernel headers match your kernel
   uname -r
   dpkg -l | grep linux-headers
   
   # If headers are missing:
   sudo apt install linux-headers-$(uname -r)
   ```

2. **Module Won't Load**:
   ```bash
   # Check detailed error messages
   sudo dmesg | tail -20
   
   # Verify module symbols
   modinfo ipv6_counter.ko
   ```

3. **No IPv6 Traffic**:
   ```bash
   # Check if IPv6 is enabled
   cat /proc/sys/net/ipv6/conf/all/disable_ipv6
   
   # Enable IPv6 if disabled (0 = enabled, 1 = disabled)
   sudo sysctl net.ipv6.conf.all.disable_ipv6=0
   
   # Check IPv6 addresses
   ip -6 addr show
   ```

4. **Permission Issues**:
   ```bash
   # Make sure you're using sudo for module operations
   sudo insmod ipv6_counter.ko
   sudo rmmod ipv6_counter
   ```

### Testing Script

Create a simple test script `test_module.sh`:

```bash
#!/bin/bash

echo "=== IPv6 Counter Module Test ==="

# Build module
echo "Building module..."
make clean && make

if [ $? -ne 0 ]; then
    echo "Build failed!"
    exit 1
fi

# Load module
echo "Loading module..."
sudo insmod ipv6_counter.ko

# Check if loaded
if lsmod | grep -q ipv6_counter; then
    echo "Module loaded successfully"
else
    echo "Module load failed"
    exit 1
fi

# Initial counter check
echo "Initial counter:"
cat /proc/ipv6_counter

# Generate traffic
echo "Generating IPv6 traffic..."
ping6 -c 10 ::1 > /dev/null 2>&1

# Check counter again
echo "Counter after traffic:"
cat /proc/ipv6_counter

# Check kernel messages
echo "Recent kernel messages:"
sudo dmesg | grep "IPv6 Counter" | tail -5

# Unload module
echo "Unloading module..."
sudo rmmod ipv6_counter

echo "Test completed!"
```

Make it executable: `chmod +x test_module.sh`

## Expected Output

When working correctly, you should see:

1. **Successful compilation** with `ipv6_counter.ko` file created
2. **Module loading** with kernel messages in dmesg
3. **Counter increments** visible in `/proc/ipv6_counter`
4. **Kernel log messages** showing packet processing (every 100 packets)
5. **Clean unloading** with final count displayed

This completes the **Basic Level** implementation. The module will count all IPv6 packets passing through the pre-routing hook and display the count via procfs.
